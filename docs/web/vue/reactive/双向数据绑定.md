---
icon: vue
author: Best Shi
time: 2021-3-18
tag:
    - Vue
    - 前端
    - 源码
    - JavaScript
    - 双休数据绑定
category: vue
---

# 双向数据绑定原理

## vue 数据响应式原理：

<img :src="$withBase('/images/数据响应式原理.png')">

## mvvm 模式：

> 数据变化视图会跟着变化。

<img :src="$withBase('/images/bestshi.com_2021-03-23_18-16-47.png')">

## 侵入式与非侵入式：

> 侵入式需要调用视图更新函数，进行数据赋值与视图更新。
>
> 非侵入式不需要调用任何函数，只要进行数据更新，视图就会跟着更新。

**侵入式：**

```js
// react
this.setState({
    a: this.state.a + 1,
});

// 小程序
this.setData({
    a: this.data.a + 1,
});
```

**非侵入式：**

```js
// vue
this.a + 1;
```

## Object.defineProperty()方法学习

::: tip Object.defineProperty()

该方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。

**参数：**

-   obj：需要定义的对象。
-   prop：需要定义或修改的属性名。
-   descriptor：要定义或修改的属性描述。
    -   configurable：该属性是否可配置（默认 false）。
    -   enumerable：该属性是否可枚举（默认 false）。
    -   writable：该属性是否可写入（默认 false）。
    -   value：该属性的值（默认 undefined）。
    -   get：该属性的 getter 函数（默认 undefined）。
    -   set：该属性的 set 函数（默认 undefined）。

**返回值：**
返回被传递给函数的对象。

:::

### 环境搭建

**安装依赖：**

```shell
npm install -D webpack webpack-cli webpack-dev-server html-webpack-plugin
```

::: info 版本信息

-   node: ==v14.13.1==
-   npm: ==v6.14.11==
-   "html-webpack-plugin": =="^5.3.1",==
-   "webpack": =="^5.27.2",==
-   "webpack-cli": =="^4.5.0",==
-   "webpack-dev-server": =="^3.11.2"==

:::

**配置 webpack.config.js**

```js
const { resolve } = require("path");
const HTMLWebpackPlugin = require("html-webpack-plugin");

module.exports = {
    entry: "./src/js/index.js",
    output: {
        filename: "js/index.js",
        path: resolve(__dirname, "dist"),
    },
    plugins: [
        new HTMLWebpackPlugin({
            template: "./src/index.html",
        }),
    ],
    devServer: {
        contentBase: resolve(__dirname, "dist"),
        port: 8001,
        open: true,
    },
};
```

```js
let obj = {};
let temp = 7;
Object.defineProperty(obj, "a", {
    enumerable: true,
    configurable: true,
    get() {
        console.log(`你试图访问${data}对象，${key}属性`);
        return temp;
    },
    set(value) {
        temp = value;
    },
});

console.log(obj.a); // 7
```

## 递归侦测对象全部属性

**defineREactive**

```js
/**
 *
 * 为Object.defineProperty()函数提供闭包环境，方便函数内部get和set方法赋值。
 *
 * @param {object} data 需要设置的对象
 * @param {string } key 需要设置对象的属性
 * @param {any} val 需要设置对象属性的值
 */

import observe from "./observe.js";

export default function defineReactive(data, key, val) {
    if (arguments.length == 2) {
        val = data[key];
    }

    // 子元素进行observe
    let childOb = observe(val);

    Object.defineProperty(data, key, {
        enumerable: true,
        configurable: true,
        get() {
            console.log(`你试图访问${data}对象，${key}属性`);
            return val;
        },
        set(value) {
            console.log(`你试图更改${data}对象，${key}属性`);
            if (val === value) {
                return;
            }
            val = value;
            childOb = observe(value);
        },
    });
}
```

**observe**

```js
/**
 * 用于侦测对象身上有没有__ob__属性
 */

import Observer from "./Observer.js";

export default function observe(value) {
    if (typeof value != "object") return;

    let ob;
    if (typeof value.__ob__ !== "undefined") {
        ob = value.__ob__;
    } else {
        ob = new Observer(value);
    }
    return ob;
}
```

**Observer**

```js
/**
 * 用于递归侦测对象的所有属性。
 * 将一个正常的object转换为每个层级的属性都是响应式（可以被侦测的）的object
 */

import { def } from "./utils.js";
import defineReactive from "./defineReactive.js";

export default class Observer {
    constructor(value) {
        // 给实例添加了__ob__属性，值是这次new的实例。
        def(value, "__ob__", this, false);
        console.log("我是Observer构造器", value);
        this.walk(value);
    }

    // 遍历
    walk(value) {
        for (let k in value) {
            defineReactive(value, k);
        }
    }
}
```

**utils**

```js
export const def = function(obj, key, value, enumerable) {
    Object.defineProperty(obj, key, {
        value,
        enumerable,
        writable: true,
        configurable: true,
    });
};
```
